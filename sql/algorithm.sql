-- =============================================
-- AUTO_INCREMENT 적용된 최종 알고리즘 도메인 MySQL DDL
-- =============================================
SET NAMES utf8mb4;
SET CHARACTER SET utf8mb4;
-- -- 데이터베이스 생성
CREATE DATABASE IF NOT EXISTS `algo` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE `algo`;
-- -- =============================================
-- -- 0. 사용자 테이블 (외래키 참조를 위해 먼저 생성)
-- -- =============================================
--     create table USERS
-- (
--     USER_ID           bigint auto_increment
--         primary key,
--     USER_EMAIL        varchar(255)                                               not null,
--     USER_PW           varchar(255)                                               not null,
--     USER_NAME         varchar(100)                                               not null,
--     USER_NICKNAME     varchar(50)                                                not null,
--     USER_IMAGE        varchar(500)                                               null,
--     USER_GRADE        int                              default 1                 not null,
--     USER_ROLE         enum ('ROLE_USER', 'ROLE_ADMIN') default 'ROLE_USER'       not null,
--     USER_ISDELETED    tinyint(1)                       default 0                 not null,
--     USER_DELETEDAT    datetime                                                   null,
--     USER_CREATEDAT    datetime                         default CURRENT_TIMESTAMP not null,
--     USER_UPDATEDAT    datetime                         default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
--     USER_ENABLED      tinyint(1)                       default 1                 not null,
--     USER_ISSUBSCRIBED tinyint(1)                       default 0                 not null,
--     constraint UQ_USERS_EMAIL
--         unique (USER_EMAIL),
--     constraint UQ_USERS_NICKNAME
--         unique (USER_NICKNAME)
-- );
-- INSERT INTO USERS (USER_ID, USER_EMAIL, USER_PW, USER_NAME, USER_NICKNAME, USER_IMAGE, USER_GRADE, USER_ROLE, USER_ISDELETED, USER_DELETEDAT, USER_CREATEDAT, USER_UPDATEDAT, USER_ENABLED, USER_ISSUBSCRIBED) 
-- VALUES (1, 'dummyuser@example.com', '$2a$10$abcdefghijklmnopqrstuvwxyz0123456789.hashed.password.string', '테스트사용자', '더미닉네임1', NULL, 1, 'ROLE_USER', 0, NULL, NOW(), NOW(), 1, 0);
-- =============================================
-- 1. 알고리즘 문제 테이블 (SQL 문제 지원 추가)
-- =============================================
CREATE TABLE `ALGO_PROBLEMS` (
    `ALGO_PROBLEM_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '문제 고유 식별자',
    `ALGO_PROBLEM_TITLE` VARCHAR(255) NOT NULL COMMENT '문제 제목',
    `ALGO_PROBLEM_DESCRIPTION` TEXT NOT NULL COMMENT '문제 상세 설명',
    `ALGO_PROBLEM_DIFFICULTY` ENUM('BRONZE', 'SILVER', 'GOLD', 'PLATINUM') NOT NULL COMMENT '문제 난이도',
    `ALGO_PROBLEM_SOURCE` ENUM('AI_GENERATED', 'BOJ', 'CUSTOM') NOT NULL COMMENT '문제 생성 출처',
    -- 문제 유형 및 SQL 문제용 스크립트 추가
    `PROBLEM_TYPE` ENUM('ALGORITHM', 'SQL') DEFAULT 'ALGORITHM' NOT NULL COMMENT '문제 유형',
    `INIT_SCRIPT` TEXT NULL COMMENT 'SQL 문제용 초기화 스크립트 (CREATE/INSERT)',
    `TIMELIMIT` INT DEFAULT 1000 COMMENT '기본 시간 제한(ms)',
    `MEMORYLIMIT` INT DEFAULT 256 COMMENT '기본 메모리 제한(MB)',
    `ALGO_CREATER` BIGINT NULL COMMENT '문제 생성자 ID',
    `ALGO_CREATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '생성 일시',
    `ALGO_UPDATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정 일시',
    `ALGO_PROBLEM_TAGS` JSON NULL COMMENT '문제 태그 배열',
    `ALGO_PROBLEM_STATUS` TINYINT(1) DEFAULT 1 COMMENT '문제 활성화 상태',
    -- LLM 문제 생성 전용 컬럼
    `CONSTRAINTS` TEXT NULL COMMENT '제약 조건 (LLM 생성)',
    `INPUT_FORMAT` TEXT NULL COMMENT '입력 형식 설명 (LLM 생성)',
    `OUTPUT_FORMAT` TEXT NULL COMMENT '출력 형식 설명 (LLM 생성)'
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '알고리즘 문제';
-- =============================================
-- 2. 언어 테이블 (Judge0 ID를 PK로 사용)
-- =============================================
-- 변경 사유:
-- 1. 보안 강화: FK 제약으로 유효한 언어만 제출 가능
-- 2. 코드 단순화: Judge0 ID를 PK로 사용하여 매핑 로직 제거
-- 3. Piston 지원: PISTON_LANGUAGE 컬럼으로 Piston API 호환
CREATE TABLE `LANGUAGES` (
    `LANGUAGE_ID` INT PRIMARY KEY COMMENT 'Judge0 language_id (PK)',
    `LANGUAGE_NAME` VARCHAR(50) NOT NULL UNIQUE COMMENT '표시용 언어명',
    `PISTON_LANGUAGE` VARCHAR(30) NULL COMMENT 'Piston API용 언어명',
    `LANGUAGE_TYPE` ENUM('GENERAL', 'DB') DEFAULT 'GENERAL' NOT NULL COMMENT '언어 유형',
    `TIME_FACTOR` DECIMAL(3, 1) DEFAULT 1.0 COMMENT '시간 제한 배수',
    `TIME_ADDITION` INT DEFAULT 0 COMMENT '시간 제한 추가(ms)',
    `MEMORY_FACTOR` DECIMAL(3, 1) DEFAULT 1.0 COMMENT '메모리 제한 배수',
    `MEMORY_ADDITION` INT DEFAULT 0 COMMENT '메모리 제한 추가(MB)'
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '언어별 채점 상수 (Judge0 ID 기반)';
-- =============================================
-- 3. 알고리즘 테스트케이스 테이블
-- =============================================
CREATE TABLE `ALGO_TESTCASES` (
    `TESTCASE_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '테스트케이스 고유 식별자',
    `INPUT_DATA` TEXT NOT NULL COMMENT '테스트 입력값',
    `EXPECTED_OUTPUT` TEXT NOT NULL COMMENT '예상 출력값',
    `IS_SAMPLE` TINYINT(1) DEFAULT 0 COMMENT '샘플 테스트케이스 여부',
    `ALGO_PROBLEM_ID` BIGINT NOT NULL COMMENT '문제 고유 식별자',
    -- 외래키
    FOREIGN KEY (`ALGO_PROBLEM_ID`) REFERENCES `ALGO_PROBLEMS`(`ALGO_PROBLEM_ID`) ON DELETE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '알고리즘 테스트케이스';
-- =============================================
-- 4. 알고리즘 제출 테이블
-- =============================================
-- 변경사항:
-- - FOCUS_SCORE, FOCUS_SESSION_ID, EYETRACKED 컬럼 제거 (모니터링이 점수에 미반영)
-- - SOLVE_MODE 추가: 'BASIC'(자유 풀이) vs 'FOCUS'(집중 모드 - 시간제한+모니터링)
-- - MONITORING_SESSION_ID 추가: 모니터링 세션과 연결
CREATE TABLE `ALGO_SUBMISSIONS` (
    `ALGOSUBMISSION_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '제출 고유 식별자',
    `ALGO_PROBLEM_ID` BIGINT NOT NULL COMMENT '문제 고유 식별자',
    `USER_ID` BIGINT NOT NULL COMMENT '제출자 ID',
    `SOURCE_CODE` TEXT NOT NULL COMMENT '제출한 소스코드',
    `LANGUAGE_ID` INT NOT NULL COMMENT '제출 언어 ID (LANGUAGES.LANGUAGE_ID FK)',
    `EXECUTION_TIME` INT NULL COMMENT '실행 시간(ms)',
    `MEMORY_USAGE` INT NULL COMMENT '메모리 사용량(MB)',
    `PASSED_TEST_COUNT` INT DEFAULT 0 COMMENT '통과한 테스트케이스 수',
    `TOTAL_TEST_COUNT` INT DEFAULT 0 COMMENT '전체 테스트케이스 수',
    `AI_FEEDBACK` TEXT NULL COMMENT 'AI 코드 리뷰 결과',
    `AI_FEEDBACK_STATUS` ENUM('PENDING', 'COMPLETED', 'FAILED') DEFAULT 'PENDING' COMMENT 'AI 리뷰 진행 상태',
    `AI_FEEDBACK_TYPE` ENUM(
        'QUALITY',
        'PERFORMANCE',
        'STYLE',
        'COMPREHENSIVE'
    ) DEFAULT 'COMPREHENSIVE' COMMENT 'AI 피드백 유형',
    `JUDGE_RESULT` ENUM('AC', 'WA', 'TLE', 'MLE', 'RE', 'CE', 'PENDING') DEFAULT 'PENDING' COMMENT '채점 결과',
    `SOLVE_MODE` ENUM('BASIC', 'FOCUS') DEFAULT 'BASIC' COMMENT '풀이 모드 (BASIC: 자유, FOCUS: 집중모드)',
    `MONITORING_SESSION_ID` VARCHAR(255) NULL COMMENT '연결된 모니터링 세션 ID (FOCUS 모드일 때만)',
    `AI_SCORE` DECIMAL(5, 2) DEFAULT 0.00 COMMENT 'AI 코드 품질 점수 (0-100)',
    `TIME_EFFICIENCY_SCORE` DECIMAL(5, 2) DEFAULT 0.00 COMMENT '시간 효율성 점수 (0-100)',
    `FINAL_SCORE` DECIMAL(5, 2) DEFAULT 0.00 COMMENT '최종 종합 점수 (0-100)',
    `SCORE_WEIGHTS` JSON NULL COMMENT '점수 가중치 정보',
    `STARTSOLVING` TIMESTAMP NULL COMMENT '문제 풀이 시작 시각',
    `ENDSOLVING` TIMESTAMP NULL COMMENT '문제 풀이 종료 시각',
    `SOLVING_DURATION_SECONDS` INT NULL COMMENT '총 풀이 소요 시간(초)',
    `GITHUB_COMMIT_URL` VARCHAR(500) NULL COMMENT 'GitHub 커밋 URL (NULL: 미커밋, 값: 커밋완료)',
    `SUBMITTED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '제출 시각',
    `IS_SHARED` TINYINT(1) DEFAULT 0 COMMENT '게시글로 공유 여부',
    -- 외래키
    FOREIGN KEY (`ALGO_PROBLEM_ID`) REFERENCES `ALGO_PROBLEMS`(`ALGO_PROBLEM_ID`) ON DELETE CASCADE,
    FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE,
    FOREIGN KEY (`LANGUAGE_ID`) REFERENCES `LANGUAGES`(`LANGUAGE_ID`)
) ENGINE = InnoDB AUTO_INCREMENT = 1000 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '알고리즘 제출 기록';

-- 사용자별 AC 문제 조회용 복합 인덱스
CREATE INDEX idx_user_problem_ac
ON ALGO_SUBMISSIONS(USER_ID, ALGO_PROBLEM_ID, JUDGE_RESULT);

-- =============================================
-- 5. 모니터링 세션 테이블 (집중 모드 전용)
-- =============================================
-- 설계 근거:
-- 1. 기존 FOCUS_SESSIONS + FOCUS_SUMMARY + VIOLATION_LOGS 3개 테이블을 1개로 통합
-- 2. 위반 유형별 개별 카운트 컬럼 사용 (JSON 대신) → 쿼리 단순화, 인덱스 활용 가능
-- 3. 모니터링은 점수에 영향 없음 (정보 제공 및 경고 목적)
-- 4. FOCUS 모드에서만 생성됨 (BASIC 모드에서는 생성 안함)
CREATE TABLE `MONITORING_SESSIONS` (
    `SESSION_ID` VARCHAR(255) PRIMARY KEY COMMENT '세션 고유 식별자 (UUID)',
    `USER_ID` BIGINT NOT NULL COMMENT '사용자 ID',
    `ALGO_PROBLEM_ID` BIGINT NOT NULL COMMENT '문제 ID',
    `ALGOSUBMISSION_ID` BIGINT NULL COMMENT '연결된 제출 ID (제출 후 연결)',
    -- 세션 상태 및 시간
    `SESSION_STATUS` ENUM('ACTIVE', 'COMPLETED', 'TIMEOUT', 'TERMINATED') DEFAULT 'ACTIVE' COMMENT '세션 상태',
    `STARTED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '세션 시작 시각',
    `ENDED_AT` TIMESTAMP NULL COMMENT '세션 종료 시각',
    -- 시간 제한 설정
    `TIME_LIMIT_MINUTES` INT NOT NULL COMMENT '설정된 제한 시간(분)',
    `REMAINING_SECONDS` INT NULL COMMENT '종료 시 남은 시간(초)',
    `AUTO_SUBMITTED` TINYINT(1) DEFAULT 0 COMMENT '시간 초과로 자동 제출 여부',
    -- 위반 유형별 카운트 (각 모니터링 요소)
    `GAZE_AWAY_COUNT` INT DEFAULT 0 COMMENT '시선 이탈 횟수',
    `SLEEPING_COUNT` INT DEFAULT 0 COMMENT '졸음 감지 횟수',
    `NO_FACE_COUNT` INT DEFAULT 0 COMMENT '얼굴 미감지 횟수 (자리비움)',
    `MASK_DETECTED_COUNT` INT DEFAULT 0 COMMENT '마스크 착용 감지 횟수',
    `MULTIPLE_FACES_COUNT` INT DEFAULT 0 COMMENT '복수 인원 감지 횟수',
    `MOUSE_LEAVE_COUNT` INT DEFAULT 0 COMMENT '마우스 화면 이탈 횟수',
    `TAB_SWITCH_COUNT` INT DEFAULT 0 COMMENT '탭/브라우저 전환 횟수',
    `FULLSCREEN_EXIT_COUNT` INT DEFAULT 0 COMMENT '전체화면 해제 횟수',
    -- 집계
    `TOTAL_VIOLATIONS` INT DEFAULT 0 COMMENT '총 위반 횟수',
    `WARNING_SHOWN_COUNT` INT DEFAULT 0 COMMENT '경고 팝업 표시 횟수',
    -- 집중도 점수 통계 (Focus Score Stats)
    `FOCUS_AVG_SCORE` DOUBLE DEFAULT NULL COMMENT '평균 집중도 점수 (-100 ~ +100)',
    `FOCUS_FINAL_SCORE` DOUBLE DEFAULT NULL COMMENT '최종 집중도 점수',
    `FOCUS_FOCUSED_PERCENTAGE` DOUBLE DEFAULT NULL COMMENT '집중 시간 비율 (%)',
    `FOCUS_HIGH_FOCUS_PERCENTAGE` DOUBLE DEFAULT NULL COMMENT '고집중 시간 비율 (%)',
    `FOCUS_TOTAL_TIME` BIGINT DEFAULT NULL COMMENT '총 측정 시간 (ms)',
    `FOCUS_FOCUSED_TIME` BIGINT DEFAULT NULL COMMENT '집중 상태 시간 (ms)',
    -- 외래키
    FOREIGN KEY (`ALGO_PROBLEM_ID`) REFERENCES `ALGO_PROBLEMS`(`ALGO_PROBLEM_ID`) ON DELETE CASCADE,
    FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '집중 모드 모니터링 세션';
-- =============================================
-- 6. 사용자 GitHub 자동커밋 설정 테이블
-- =============================================
-- 설계 근거:
-- 1. USERS 테이블 수정 최소화 (Single Responsibility)
-- 2. 1:1 관계로 사용자별 설정 관리
-- 3. 커밋 이력은 GitHub 자체가 Single Source of Truth
CREATE TABLE `USER_GITHUB_SETTINGS` (
    `SETTING_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '설정 고유 식별자',
    `USER_ID` BIGINT NOT NULL UNIQUE COMMENT '사용자 ID (1:1 관계)',
    `GITHUB_REPO_NAME` VARCHAR(255) NULL COMMENT '연동된 저장소명 (예: coai-solutions)',
    `GITHUB_REPO_URL` VARCHAR(500) NULL COMMENT '저장소 전체 URL',
    `AUTO_COMMIT_ENABLED` TINYINT(1) DEFAULT 0 NOT NULL COMMENT '자동 커밋 활성화 여부',
    `CREATED_AT` DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL COMMENT '생성 일시',
    `UPDATED_AT` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정 일시',
    -- 외래키
    CONSTRAINT `FK_GITHUB_SETTINGS_USER`
        FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE,
    -- 인덱스
    INDEX `idx_auto_commit` (`AUTO_COMMIT_ENABLED`)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '사용자 GitHub 자동커밋 설정';

-- =============================================
-- AUTO_INCREMENT 시작값 설정
-- =============================================
ALTER TABLE `ALGO_PROBLEMS` AUTO_INCREMENT = 1;
ALTER TABLE `ALGO_TESTCASES` AUTO_INCREMENT = 1;
ALTER TABLE `ALGO_SUBMISSIONS` AUTO_INCREMENT = 1000;
ALTER TABLE `USER_GITHUB_SETTINGS` AUTO_INCREMENT = 1;
-- =============================================
-- 언어 데이터 삽입 (Judge0 ID 기반 + Piston 지원)
-- =============================================
-- LANGUAGE_ID = Judge0 API language_id
-- PISTON_LANGUAGE = Piston API용 언어명
INSERT INTO LANGUAGES (LANGUAGE_ID, LANGUAGE_NAME, PISTON_LANGUAGE, LANGUAGE_TYPE, TIME_FACTOR, TIME_ADDITION, MEMORY_FACTOR, MEMORY_ADDITION) VALUES
(71, 'Python', 'python', 'GENERAL', 3.0, 2000, 2.0, 32),
(63, 'JavaScript', 'javascript', 'GENERAL', 3.0, 2000, 2.0, 2),
(62, 'Java', 'java', 'GENERAL', 2.0, 1000, 2.0, 16),
(51, 'C#', 'csharp.net', 'GENERAL', 2.0, 1000, 2.0, 16),
(54, 'C++', 'c++', 'GENERAL', 1.0, 0, 1.0, 0),
(60, 'Go', 'go', 'GENERAL', 1.0, 2000, 1.0, 512),
(74, 'TypeScript', 'typescript', 'GENERAL', 3.0, 2000, 2.0, 2),
(78, 'Kotlin', 'kotlin', 'GENERAL', 2.0, 1000, 2.0, 16),
(83, 'Swift', 'swift', 'GENERAL', 1.0, 0, 1.0, 512),
(73, 'Rust', 'rust', 'GENERAL', 1.0, 0, 1.0, 0),
(82, 'SQLite', 'sqlite3', 'DB', 1.0, 0, 1.0, 0);
-- =============================================
-- ALGO_PROBLEMS 더미 데이터 삽입 (10개, ID 1부터 시작)
-- =============================================
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('배열의 합 구하기', 'N개의 정수가 주어졌을 때, 모든 정수의 합을 구하세요.', 'BRONZE', 'AI_GENERATED', 'ALGORITHM', NULL, 1000, 256, 1, '["구현/시뮬레이션"]', 1, '1 <= N <= 10000, -1000 <= 각 정수 <= 1000', '첫째 줄에 정수의 개수 N이 주어진다.\n둘째 줄에 N개의 정수가 공백으로 구분되어 주어진다.', '첫째 줄에 모든 정수의 합을 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('문자열 뒤집기', '주어진 문자열을 뒤집어서 출력하세요.', 'BRONZE', 'AI_GENERATED', 'ALGORITHM', NULL, 1000, 256, 1, '["문자열 처리"]', 1, '1 <= 문자열 길이 <= 1000', '첫째 줄에 영문 소문자로 이루어진 문자열이 주어진다.', '첫째 줄에 뒤집은 문자열을 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('스택으로 괄호 검사', '주어진 괄호 문자열이 올바른지 판별하세요. 올바르면 YES, 아니면 NO를 출력합니다.', 'SILVER', 'AI_GENERATED', 'ALGORITHM', NULL, 1000, 256, 1, '["스택/큐"]', 1, '1 <= 문자열 길이 <= 100000', '첫째 줄에 괄호로 이루어진 문자열이 주어진다. (소괄호, 중괄호, 대괄호)', '올바른 괄호면 YES, 아니면 NO를 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('이진 탐색', '정렬된 배열에서 특정 값 K가 존재하는지 이진 탐색으로 확인하세요. 존재하면 인덱스(1-based), 없으면 -1을 출력합니다.', 'SILVER', 'AI_GENERATED', 'ALGORITHM', NULL, 1000, 256, 1, '["이분탐색"]', 1, '1 <= N <= 100000, 1 <= 각 원소, K <= 10^9', '첫째 줄에 배열의 크기 N과 찾을 값 K가 주어진다.\n둘째 줄에 오름차순 정렬된 N개의 정수가 주어진다.', '값이 존재하면 인덱스(1-based), 없으면 -1을 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('숫자 정렬하기', 'N개의 정수를 오름차순으로 정렬하세요.', 'SILVER', 'AI_GENERATED', 'ALGORITHM', NULL, 2000, 256, 1, '["정렬"]', 1, '1 <= N <= 100000, -10^9 <= 각 정수 <= 10^9', '첫째 줄에 정수의 개수 N이 주어진다.\n둘째 줄에 N개의 정수가 공백으로 구분되어 주어진다.', '오름차순으로 정렬된 N개의 정수를 공백으로 구분하여 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('회의실 배정', 'N개의 회의에 대해 시작 시간과 끝 시간이 주어질 때, 한 회의실에서 최대 몇 개의 회의를 진행할 수 있는지 구하세요.', 'GOLD', 'AI_GENERATED', 'ALGORITHM', NULL, 1000, 256, 1, '["그리디"]', 1, '1 <= N <= 100000, 0 <= 시작 시간 < 끝 시간 <= 2^31-1', '첫째 줄에 회의의 수 N이 주어진다.\n다음 N개의 줄에 각 회의의 시작 시간과 끝 시간이 주어진다.', '첫째 줄에 최대 회의 개수를 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('연결 요소의 개수', '무방향 그래프에서 연결 요소(Connected Component)의 개수를 구하세요.', 'GOLD', 'AI_GENERATED', 'ALGORITHM', NULL, 2000, 512, 1, '["DFS/BFS"]', 1, '1 <= N <= 1000, 0 <= M <= N*(N-1)/2', '첫째 줄에 정점의 수 N과 간선의 수 M이 주어진다.\n다음 M개의 줄에 간선 정보 u v가 주어진다.', '첫째 줄에 연결 요소의 개수를 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('0/1 배낭 문제', 'N개의 물건과 최대 무게 W인 배낭이 있을 때, 배낭에 담을 수 있는 물건들의 최대 가치를 구하세요.', 'GOLD', 'AI_GENERATED', 'ALGORITHM', NULL, 2000, 512, 1, '["동적 프로그래밍(DP)"]', 1, '1 <= N <= 100, 1 <= W <= 100000, 1 <= 무게, 가치 <= 1000', '첫째 줄에 물건의 수 N과 배낭의 최대 무게 W가 주어진다.\n다음 N개의 줄에 각 물건의 무게와 가치가 공백으로 구분되어 주어진다.', '첫째 줄에 배낭에 담을 수 있는 물건들의 최대 가치를 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('다익스트라 최단 경로', '방향 가중치 그래프에서 시작 정점 S로부터 모든 정점까지의 최단 거리를 구하세요. 도달 불가능하면 INF를 출력합니다.', 'PLATINUM', 'AI_GENERATED', 'ALGORITHM', NULL, 3000, 512, 1, '["그래프/최단경로"]', 1, '1 <= N <= 20000, 1 <= M <= 300000, 1 <= 가중치 <= 10', '첫째 줄에 정점의 수 N과 간선의 수 M이 주어진다.\n둘째 줄에 시작 정점 S가 주어진다.\n다음 M개의 줄에 간선 정보 u v w가 주어진다.', '각 정점까지의 최단 거리를 한 줄씩 출력한다. 도달 불가능하면 INF를 출력한다.');
INSERT INTO ALGO_PROBLEMS (ALGO_PROBLEM_TITLE, ALGO_PROBLEM_DESCRIPTION, ALGO_PROBLEM_DIFFICULTY, ALGO_PROBLEM_SOURCE, PROBLEM_TYPE, INIT_SCRIPT, TIMELIMIT, MEMORYLIMIT, ALGO_CREATER, ALGO_PROBLEM_TAGS, ALGO_PROBLEM_STATUS, CONSTRAINTS, INPUT_FORMAT, OUTPUT_FORMAT) VALUES ('N-Queen', 'N×N 체스판에 N개의 퀸을 서로 공격하지 못하게 놓는 경우의 수를 구하세요.', 'PLATINUM', 'AI_GENERATED', 'ALGORITHM', NULL, 5000, 256, 1, '["백트래킹"]', 1, '1 <= N <= 14', '첫째 줄에 N이 주어진다.', '첫째 줄에 경우의 수를 출력한다.');

-- =============================================
-- ALGO_TESTCASES 더미 데이터 삽입 (각 문제당 5개, 총 50개)
-- =============================================
-- 문제 ID 1: 배열의 합 구하기
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (1, '5\n1 2 3 4 5', '15', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (1, '3\n-1 0 1', '0', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (1, '1\n100', '100', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (1, '4\n-500 -500 1000 0', '0', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (1, '6\n10 20 30 40 50 60', '210', 0);

-- 문제 ID 2: 문자열 뒤집기
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (2, 'hello', 'olleh', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (2, 'algorithm', 'mhtirogla', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (2, 'a', 'a', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (2, 'abcdefghij', 'jihgfedcba', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (2, 'racecar', 'racecar', 0);

-- 문제 ID 3: 스택으로 괄호 검사
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (3, '(())()', 'YES', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (3, '([)]', 'NO', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (3, '{[()]}', 'YES', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (3, '((((', 'NO', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (3, '[]{}()', 'YES', 0);

-- 문제 ID 4: 이진 탐색
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (4, '5 3\n1 2 3 4 5', '3', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (4, '5 6\n1 2 3 4 5', '-1', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (4, '1 1\n1', '1', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (4, '7 50\n10 20 30 40 50 60 70', '5', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (4, '4 100\n1 2 3 99', '-1', 0);

-- 문제 ID 5: 숫자 정렬하기
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (5, '5\n5 4 3 2 1', '1 2 3 4 5', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (5, '3\n3 1 2', '1 2 3', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (5, '1\n42', '42', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (5, '4\n-5 0 5 -10', '-10 -5 0 5', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (5, '6\n1 1 1 2 2 2', '1 1 1 2 2 2', 0);

-- 문제 ID 6: 회의실 배정
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (6, '5\n1 4\n3 5\n0 6\n5 7\n3 8', '3', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (6, '3\n1 2\n2 3\n3 4', '3', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (6, '1\n0 100', '1', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (6, '4\n0 1\n1 2\n2 3\n3 4', '4', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (6, '3\n0 10\n5 15\n10 20', '2', 0);

-- 문제 ID 7: 연결 요소의 개수
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (7, '6 5\n1 2\n2 5\n5 1\n3 4\n4 6', '2', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (7, '6 8\n1 2\n2 3\n3 1\n4 5\n5 6\n6 4\n2 4\n3 6', '1', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (7, '3 0', '3', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (7, '4 3\n1 2\n2 3\n3 4', '1', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (7, '5 2\n1 2\n3 4', '3', 0);

-- 문제 ID 8: 0/1 배낭 문제
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (8, '4 7\n6 13\n4 8\n3 6\n5 12', '14', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (8, '3 10\n5 10\n4 40\n6 30', '70', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (8, '1 5\n10 100', '0', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (8, '2 100\n50 60\n50 100', '160', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (8, '5 15\n3 10\n4 20\n5 30\n6 40\n7 50', '80', 0);

-- 문제 ID 9: 다익스트라 최단 경로
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (9, '5 6\n1\n5 1 1\n1 2 2\n1 3 3\n2 3 4\n2 4 5\n3 4 6', '0\n2\n3\n7\nINF', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (9, '3 2\n1\n1 2 5\n2 3 5', '0\n5\n10', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (9, '3 0\n1', '0\nINF\nINF', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (9, '4 5\n2\n1 2 1\n2 1 1\n2 3 1\n3 4 1\n4 2 1', 'INF\n0\n1\n2', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (9, '2 2\n1\n1 2 3\n1 2 5', '0\n3', 0);

-- 문제 ID 10: N-Queen
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (10, '4', '2', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (10, '8', '92', 1);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (10, '1', '1', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (10, '5', '10', 0);
INSERT INTO ALGO_TESTCASES (ALGO_PROBLEM_ID, INPUT_DATA, EXPECTED_OUTPUT, IS_SAMPLE) VALUES (10, '10', '724', 0);

-- =============================================
-- LLM 문제 생성 관련 테이블 확장
-- =============================================

-- 문제 생성 검증 로그 테이블 (개발자 품질 검사용)
CREATE TABLE `PROBLEM_VALIDATION_LOGS` (
    `VALIDATION_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '검증 로그 고유 식별자',
    `ALGO_PROBLEM_ID` BIGINT NOT NULL COMMENT '연관된 문제 ID',

    -- LLM이 생성한 코드 (품질 검증용)
    `OPTIMAL_CODE` TEXT NULL COMMENT '최적 정답 코드',
    `NAIVE_CODE` TEXT NULL COMMENT '비효율적 코드 (시간 복잡도 비교용)',
    `EXPECTED_TIME_COMPLEXITY` VARCHAR(50) NULL COMMENT '예상 시간 복잡도 (예: O(n log n))',

    -- 코드 실행 검증 결과
    `OPTIMAL_CODE_RESULT` ENUM('PASS', 'FAIL', 'ERROR', 'TIMEOUT') NULL COMMENT '최적 코드 실행 결과',
    `NAIVE_CODE_RESULT` ENUM('PASS', 'FAIL', 'ERROR', 'TIMEOUT') NULL COMMENT '비효율 코드 실행 결과',
    `OPTIMAL_EXECUTION_TIME` INT NULL COMMENT '최적 코드 실행 시간(ms)',
    `NAIVE_EXECUTION_TIME` INT NULL COMMENT '비효율 코드 실행 시간(ms)',
    `TIME_RATIO` DECIMAL(10, 2) NULL COMMENT '시간 비율 (naive / optimal)',
    `TIME_RATIO_VALID` TINYINT(1) DEFAULT NULL COMMENT '시간 비율 검증 통과 여부',

    -- 유사도 검사 결과
    `SIMILARITY_SCORE` DECIMAL(5, 2) NULL COMMENT '기존 문제와의 유사도 점수 (0-100)',
    `SIMILARITY_VALID` TINYINT(1) DEFAULT NULL COMMENT '유사도 검증 통과 여부 (80% 이하)',

    -- 검증 상태 및 Self-Correction
    `VALIDATION_STATUS` ENUM('PENDING', 'PASSED', 'FAILED', 'CORRECTED') DEFAULT 'PENDING' COMMENT '검증 상태',
    `CORRECTION_ATTEMPTS` INT DEFAULT 0 COMMENT 'Self-Correction 시도 횟수',
    `FAILURE_REASONS` JSON NULL COMMENT '검증 실패 원인들',

    -- 타임스탬프
    `CREATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '검증 생성 일시',
    `COMPLETED_AT` TIMESTAMP NULL COMMENT '검증 완료 일시',

    -- 외래키 및 인덱스
    FOREIGN KEY (`ALGO_PROBLEM_ID`) REFERENCES `ALGO_PROBLEMS`(`ALGO_PROBLEM_ID`) ON DELETE CASCADE,
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '문제 생성 검증 로그 (개발자용)';

-- =============================================
-- Rate Limiting & Daily Mission 테이블
-- =============================================

-- 사용자 일일 사용량 추적 테이블 (히스토리 보존용)
CREATE TABLE `USER_DAILY_USAGE` (
    `USAGE_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '사용량 고유 식별자',
    `USER_ID` BIGINT NOT NULL COMMENT '사용자 ID',
    `USAGE_DATE` DATE NOT NULL COMMENT '사용 날짜',
    `GENERATE_COUNT` INT DEFAULT 0 COMMENT 'AI 문제 생성 횟수',
    `SOLVE_COUNT` INT DEFAULT 0 COMMENT '문제 풀기 횟수',
    `CREATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '생성 일시',
    `UPDATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정 일시',

    UNIQUE KEY `uk_user_date` (`USER_ID`, `USAGE_DATE`),
    INDEX `idx_usage_date` (`USAGE_DATE`),
    FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '사용자 일일 사용량';

-- 데일리 미션 테이블
CREATE TABLE `DAILY_MISSIONS` (
    `MISSION_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '미션 고유 식별자',
    `USER_ID` BIGINT NOT NULL COMMENT '사용자 ID',
    `MISSION_DATE` DATE NOT NULL COMMENT '미션 날짜',
    `MISSION_TYPE` ENUM('PROBLEM_GENERATE', 'PROBLEM_SOLVE') NOT NULL COMMENT '미션 유형',
    `PROBLEM_ID` BIGINT NULL COMMENT '풀어야 할 문제 ID (PROBLEM_SOLVE 타입)',
    `IS_COMPLETED` TINYINT(1) DEFAULT 0 COMMENT '완료 여부',
    `REWARD_POINTS` INT DEFAULT 0 COMMENT '보상 포인트',
    `COMPLETED_AT` TIMESTAMP NULL COMMENT '완료 일시',
    `CREATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '생성 일시',

    UNIQUE KEY `uk_user_date_type` (`USER_ID`, `MISSION_DATE`, `MISSION_TYPE`),
    INDEX `idx_mission_date` (`MISSION_DATE`),
    INDEX `idx_user_completed` (`USER_ID`, `IS_COMPLETED`),
    FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE,
    FOREIGN KEY (`PROBLEM_ID`) REFERENCES `ALGO_PROBLEMS`(`ALGO_PROBLEM_ID`) ON DELETE SET NULL
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '데일리 미션';

-- 사용자 레벨 테이블 (알고리즘 레벨)
CREATE TABLE `USER_ALGO_LEVELS` (
    `LEVEL_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '레벨 고유 식별자',
    `USER_ID` BIGINT NOT NULL UNIQUE COMMENT '사용자 ID',
    `ALGO_LEVEL` ENUM('EMERALD', 'SAPPHIRE', 'RUBY', 'DIAMOND') DEFAULT 'EMERALD' COMMENT '알고리즘 레벨',
    `TOTAL_SOLVED` INT DEFAULT 0 COMMENT '총 푼 문제 수',
    `CURRENT_STREAK` INT DEFAULT 0 COMMENT '현재 연속 풀이 일수',
    `MAX_STREAK` INT DEFAULT 0 COMMENT '최대 연속 풀이 일수',
    `LAST_SOLVED_AT` TIMESTAMP NULL COMMENT '마지막 풀이 일시',
    `CREATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '생성 일시',
    `UPDATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정 일시',

    FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '사용자 알고리즘 레벨';

-- =============================================
-- AI 문제 사전 생성 풀 테이블
-- =============================================
-- 목적: 사전 생성된 AI 문제를 조합별로 저장하여 즉시 제공
-- 흐름: ALGO_PROBLEM_POOL(대기) → 소비 시 삭제 → ALGO_PROBLEMS(영구 저장)으로 이동
-- 조합: 4 난이도 × 15 주제 × 5 테마 = 300개 조합, 조합당 5개 = 총 1,500개 목표
CREATE TABLE `ALGO_PROBLEM_POOL` (
    `ALGO_POOL_ID` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '풀 문제 고유 식별자',

    -- 문제 분류 (조합 키)
    `DIFFICULTY` VARCHAR(20) NOT NULL COMMENT '난이도: BRONZE, SILVER, GOLD, PLATINUM',
    `TOPIC` VARCHAR(50) NOT NULL COMMENT '알고리즘 주제 (15개 - ProblemTopic enum 참조)',
    `THEME` VARCHAR(50) NOT NULL COMMENT '스토리 테마: 계절별 변경 가능, 현재 5개',

    -- 문제 내용 (JSON - ALGO_PROBLEMS 테이블 구조와 동일한 형태로 저장)
    `PROBLEM_CONTENT` JSON NOT NULL COMMENT '문제 전체 데이터: title, description, testcases, constraints 등',

    -- 생성 메타데이터
    `GENERATED_AT` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '문제 생성 시각',
    `GENERATION_TIME_MS` INT NULL COMMENT 'LLM 생성 소요 시간(ms)',

    `CREATED_AT` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '레코드 생성 시각',

    -- 인덱스: 조합별 빠른 조회 (SELECT FOR UPDATE 시 사용)
    INDEX `idx_pool_combination` (`DIFFICULTY`, `TOPIC`, `THEME`),
    INDEX `idx_pool_difficulty` (`DIFFICULTY`)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = 'AI 사전 생성 문제 풀';

-- =============================================
-- 성능 최적화 설정
-- =============================================
SET GLOBAL innodb_buffer_pool_size = 1073741824;
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;
SET @@auto_increment_increment = 1;
SET @@auto_increment_offset = 1;
SET FOREIGN_KEY_CHECKS = 1;
COMMIT;
SHOW TABLES;
-- =============================================
-- 6. 사용자 실수 통계 테이블 (상습적 실수 추적용)
-- =============================================
CREATE TABLE `USER_MISTAKE_STATS` (
    `STAT_ID` BIGINT AUTO_INCREMENT PRIMARY KEY,
    `USER_ID` BIGINT NOT NULL,
    `MISTAKE_TYPE` VARCHAR(255) NOT NULL COMMENT '실수 유형 (예: Magic Number)',
    `OCCURRENCE_COUNT` INT DEFAULT 0 COMMENT '누적 발생 횟수',
    `SOLVED_COUNT` INT DEFAULT 0 COMMENT '퀴즈 통과 횟수 (30회 차감 효과)',
    `LAST_DETECTED_AT` DATETIME DEFAULT CURRENT_TIMESTAMP,
    `LAST_REPORT_GENERATED_AT` DATETIME NULL COMMENT '마지막으로 리포트가 생성된 시각',
    FOREIGN KEY (`USER_ID`) REFERENCES `USERS`(`USER_ID`) ON DELETE CASCADE,
    UNIQUE KEY `uk_user_mistake` (`USER_ID`, `MISTAKE_TYPE`)
) COMMENT = '사용자 실수 누적 통계';

-- AUTO_INCREMENT 값 설정
ALTER TABLE `USER_MISTAKE_STATS` AUTO_INCREMENT = 1;
